What works right now:

    - SimpleVar Assignments (haven't touched arrays)
        -this includes arithmetic
        -see tests/asm1.cm
        
    - I started on If-statements but backpatching looks terrifying so I stopped for now
    
    
What I did/learned:

    !!We actually are supposed to use memory to store information!!

    Simple Declarations (SimpleDec function):
        -If it's a global declaration, decrement gpOff
        -if it's a local  declaration, decrement fpOff

    What I did so far was start in the AssignExp function
          static private int generateTable( AssignExp tree, int spaces )
          
    Then I look up the LHS variable and got the offset for it (so that we can access it relative to the fp)
    
    Then the function calls 
            generateTable(tree.rhs, -1);
            
    -If you follow the path for it (AssignExp -> VarExp -> etc..) you end up at IntExp if it's a literal number, or SimpleVar if it's a variable;
    -Instead of returning a value like we did with type checking, instead I wrote the ASM code to store the resulting value in the register.  
    -I'm using the 'spaces' argument that is passed along to flag which register to use. 0 is r0, 1 is r1, etc. -1 is don't write to a register.
    --I think we're just supposed to use r0 if we can
    
    IntExp:
        -Just emits the code for copying a literal into the register
        
    SimpleVar:
        -Gets the offset of the variable and emits the code that moves that address into the register
        
    So (back in AssignExp) after calling generateTable(tree.rhs, -1) we know that the value of the RHS is stored in r0, from there we just
    emit the code that moves it in to the address of the LHS variable using the offset we grabbed at the start.
              
    That's all I needed to do for a basic assignment like x = 10; or x = y; 
    
      
    For arithmetic I moved to OpExp
           static private int generateTable( OpExp tree, int spaces )
           
    We need to use temporary storage for this, so I calculated the result of the LHS of the operand (much like above) and stored it at the next free block
    (being sure to decrement fpOff so that it always points at an empty block)
    
    Then I did the same to the RHS.
    
    After both the LHS and the RHS are in temp memory, 
    I emit the code that moves them in to r0 and r1 respectively and then emit the code to perform whatever the operation is (MUL, ADD, etc)
    
    
    That's pretty much it. What I'm feeling is that this is similar to type checking in that the 'lower' types (like IntExp and SimpleVar) just emit the code to write 
    their value to a register (instead of returning a type) then from the 'higher' types (like AssignExp) you use the stored values and emit the more structured code
    
    
    
           

           
    
    
            
        
    

        
